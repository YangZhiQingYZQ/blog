# HTTP队头阻塞

服务器和客户端时经过三次握手创建TCP通道进行交流的，最后通过四次回收告别的。所以创建一次TCP通道是需要消耗一定资源和时间的

在HTTP0.9之前，每发送一次请求就必须创建一次TCP通道，但是一个网站往往都需要发送几十个请求，那么就需要创建几十个TCP通道，十分耗费资源；所以在HTTP1.0开始增加了Connection：Keep-Alive字段，可以让TCP连接持续打开。这样就节省了一个请求创建一次TCP通道的性能消耗

在HTTP1.1引入了持久连接和管道机制

## 持久连接

持久连接：即不用声明Connection：keep-alive字段，TCP连接默认不关闭，并且可以被多个请求复用。长连接的连接时长可以通过请求头中的keep-alive来设置

当客户端请求中含有Connection：Keep-Alive首部，服务器响应中也有Connection：Keep-Alive首部时，双方才会成功建立持久连接

在服务器返回【Connection：Keep-Alive】字段时，还可以追加【Keep-Alive：max = 5，timeout = 120】字段

以上说明，服务器最多还会为另外5个事务保持TCP连接的打开状态，或者将打开状态保持连接空闲2分钟之后

## 管道机制

HTTP1.1允许在持久连接上可选的使用请求通道。这是相对于keep-alive连接的又一性能优化。在响应达到之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开发发送了，在高延迟网络条件下，这样做可以降低网络的环回时间，提高性能

## 持久连接 + 管道机制 引发HTTP队头阻塞

HTTP管道化要求服务器必须按照请求发送的顺序返回相应，如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到对头的响应送达

### 解决方法

* 利用HTTP2的多路复用解决

对于HTTP1.1中管道化导致的请求/响应级别的对头阻塞，可以使用HTTP2的多路复用解决

HTTP2不使用管道化的方式，而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干帧进行传输，每个帧都分配一个序号。每个帧在传输时属于一个数据流，而连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后再组装成消息，这样就避免了请求/响应阻塞

即使使用HTTP2，如果HTTP2 底层使用的是TCP协议，仍然可能出现TCP队头阻塞

* 并发连接

我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在RFC规范中规定客户端最多并发2个连接，不过实际情况是要比这个还要多，如：Chrome中是6个

* 域名分片

顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，根据这点可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题


## HTTP2

* 二进制分帧：这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”：头信息帧和数据帧
* 头部压缩HTTP1.1版本会出现【User-Agent、Cookie、Accept、Server、Range】等字段可能会占用几百甚至几千字节，而Body却经常只有几十字节，所以导致头部偏重。HTTP2.0使用HPACK算法进行压缩
* 多路复用：复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了对头阻塞的问题
* 服务器推送：允许服务器未经请求，主动向客户端发送资源，即服务器推送
* 请求优先级：可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验

