# 继承

每个函数都有prototype（原型）属性（对于创建出来的实例为[[prototype]]或__proto__），这个属性是一个指针，指向一个对象，此对象用于包含可以由特定类型的所有实例共享的属性和方法

实例对象中的__proto__指向创建此对象构造函数的原型对象、继承属性等，与此对象的构造函数没有关系，只与此对象的构造函数的原型对象有关系

## 使用对象字面量形式创建新对象

使用此方式，虽然结果相同，但是constructor属性却不再指向原的函数了（指向Object对象），尽管使用instanceof（）仍然放回ture，但通过constructor已经无法确定对象类型，所以在重写时，应将constructor指回原来的对象

实例中的指针，仅指向原型，不指向构造函数，当我们把原型修改为另一个对象时，就相当于切断了构造函数与最初原型的关系

缺点：在原型对象中添加了引用类型的数据时，一旦修改里面的值，那么将会影响所有实例

## 组合使用构造函数模式和原型模式

构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性

## 原型链继承

原理：通过将构造函数的prototype赋予给需要继承的对象，来实现原型链继承

解决了同一类型对象重复创建同样功能的函数问题

但是如果需要使用的的继承的值，因为创建出来多个对象都引用此值，会导致一个对象修改后，全部对象生效；

## 借用构造函数继承

在子类型构造函数的内部调用超类型构造函数，使用call（）或apply（）方法传入子类型对象，这样就可以实现每个实例都具有自己的私有的属性或方法。相对于原型链来说，借用构造函数可以在子类型构造函数中向超类型构造函数传递参数。

缺点：方法都在构造函数中定义，无法进行复用。而且在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型只能使用构造函数模式。

## 组合继承（伪经典继承）：

指是将原型链和借用构造函数的技术组合到一块，使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，这样既在原型上定义方法实现了函数的复用，又实现了每个实例都有自己的属性。instanceof与isPrototypeOf能够识别组合继承创建的对象

## 原型继承：

没有严格意义上的构造函数，借助原型基于已有的对象创建新对象。即在函数中创建一个临时的构造函数，并将传入的对象作为此构造函数的原型，最后在return出构造函数创建的对象（使用new操作符）

ECMAScript新增Object.create()方法规范化了原型继承。可接受两个参数：一个作用新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数时，Object.create()与Object()行为相同，在传入两个参数时：第二个参数格式与Object.defineProperties()方法格式相同，每个属性都是通过自己的描述符定义的。这种方式指定的任何属性都会覆盖原型对象上的同名属性

## 寄生继承：

创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再返回对象。寄生式继承不能做到函数的复用。在主要考虑对象而不是自定义类型和构造函数下，可以使用此方式

## 寄生组合式继承：（引用类型最理想的继承范式）

借用构造函数来继承属性，通过原型链的混成形式来集成方法；本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
javaScript是通过原型链实现继承，原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。